package com.learning.scala.classobj

/* Scala: создание класса и объектов + определение поля внутри класса */

// определение класса-Customer + определение полей 'name' и 'address' с помощью конструктора
class Customer(val name: String, val address: String) {
  /*
   * ключевое слово 'val' - говорит SCALA-компилятору создавать поля и методы для доступа к общественному getter-методу (при этом не создавая setter-методов).
   * Вопрос: что делать если нужно getter-методы сделать 'private'? - просто объявить 'val' как 'private', например:
   * >   private val name: String
   */

  private var id = "" // Определение поля внутри класса
  /*
   * ключевое слово 'var' - говорит SCALA-компилятору создавать поле и оба 'getter/setter' метода.
   * По умолчанию методы 'getter/setter' являются 'public', но здесь 'private' декларация - которая создает 'private' методы.
   * Создает getter (с именем "ID") и setter (с именем "id_") - методы в Scala сгенерированные согласно правилам конвенции об именовании...
   *
   * В заключение что важно знать для определения полей?
   * #1  'val' ....... неизменное поле - создает только public getter  (эквивалент 'final' переменной в Java)
   * #2  'var' ....... изменяемом поле - создает public getter и setter
   * #3  'none' ...... если не объявить с помощью 'val/var', то не создает getter/setter
   * #4  'private' ... делает любые методы 'private'
   */
}

/*
 * Scala компилирует в два файла: - 'Customer.class' (для класса выше) и 'Customer$.class' (для объекта-синглетона)
 * ключевое слово 'object' - создает одноэлементный объект класса
 * Если имя объекта имеет такое же имя класса - то это называется 'Компаньон объекта' (companion) и он может получить доступ к закрытым методам класса
 */
object Customer {
  def main(args: Array[String]) {
    val customer = new Customer("Tirthal", "Ahmedabad 380054")
    customer.id_=("01") // вызов setter-метода
    customer.id = "01" // другой синтаксис для установки значения

    /* Раскомментируйте следующую строку чтобы увидеть ошибку компиляции, потому что поле "name" объявленно как 'val', и поэтому компилятор не сгенерирует setter-метод */
    // customer.name = "cannot change"

    println( customer.id + " | " + customer.name + " | " + customer.address )
  }
}
